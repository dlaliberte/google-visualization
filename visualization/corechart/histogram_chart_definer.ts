/**
 * @fileoverview Manages aspects of defining a histogram chart.
 *
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  clone,
  flatten,
  forEach,
  map,
} from '@npm//@closure/array/array';
import {assert} from '@npm//@closure/asserts/asserts';
import {SerieType} from '../../common/option_types';
import {Options} from '../../common/options';
import {AbstractDataTable} from '../../data/abstract_datatable';
import {DataTable} from '../../data/datatable';
import {AxisChartDefiner} from './axis_chart_definer';

import {AxisDecorationsCreator} from '../../axis/axis_decorations_creator';
import {getByType} from '../../axis/value_number_converter';
import {ColumnType, Value} from '../../data/types';
import {TextMeasureFunction} from '../../text/text_measure_function';
import {InitFunctionList} from './chart_definer';
import {ChartDefinition} from './chart_definition';
import * as chartDefinitionTypes from './chart_definition_types';
import {HistogramChartDefinition} from './histogram_chart_definition';
import {ColumnRole} from './serie_columns';

const {NUMBER, STRING} = ColumnType;

/**
 * Fills the given chart definition with histogram specific stuff.
 * @unrestricted
 */
export class HistogramChartDefiner extends AxisChartDefiner {
  /** Internally constructed DataTable. */
  // remove '!', see go/strict-prop-init-fix.
  histogramTable!: DataTable;

  // Set up value-to-number converters.
  toNumber!: Array<(p1: Value) => number>;

  /**
   * @param data The data to be drawn.
   * @param options The options controlling how the chart will look and behave.
   * @param textMeasureFunction A function for measuring width and height of text objects.
   * @param width Chart's width.
   * @param height Chart's height.
   */
  constructor(
    data: AbstractDataTable,
    options: Options,
    textMeasureFunction: TextMeasureFunction,
    width: number,
    height: number,
  ) {
    super(data, options, textMeasureFunction, width, height);
  }

  /**
   * Returns functions which initialize the chart definition, making it ready
   * to be drawn.  Each function should return either nothing or an
   * array of functions, which are inserted at the head of the queue.
   */
  override initSteps(): InitFunctionList {
    return super.initSteps();
  }

  /**
   * Construct and return the chart definition for this class.
   * @return The chart definition.
   */
  override constructChartDefinition(): ChartDefinition {
    return new HistogramChartDefinition();
  }

  /** Creates the data view for a histogram. */
  override createDataView() {
    const dataTable = this.dataTable;
    const firstColIsLabel = dataTable.getColumnType(0) === STRING;
    const colStart = firstColIsLabel ? 1 : 0;
    const numCols = dataTable.getNumberOfColumns();

    // The first column of the histogramTable will have the bucket values,
    // and subsequent columns will be the (number of) items in each bucket.
    this.histogramTable = new DataTable();
    this.histogramTable.addColumn(NUMBER, 'label');

    for (let i = colStart; i < numCols; i++) {
      /**
       * @desc Label for a data series that is generated by counting the integer
       *   number of occurrences of items in another series that fall within
       *   one of several buckets.  So this 'count' is used as a noun, is not
       *   a placeholder and should be translated.  But the $seriesName is a
       *   placeholder and will be replaced by the original series label.
       */
      const MSG_HISTOGRAM_LABEL = goog.getMsg('{$seriesName} (count)', {
        'seriesName': dataTable.getColumnLabel(i),
      });
      this.histogramTable.addColumn(NUMBER, MSG_HISTOGRAM_LABEL);
    }
    this.dataView = this.histogramTable;
  }

  /**
   * Populate the data view for a histogram, including bucketing.
   * Changes the member: this.dataView_.
   */
  override populateDataView() {
    const dataTable = this.dataTable;
    const firstColIsLabel = dataTable.getColumnType(0) === 'string';
    const colStart = firstColIsLabel ? 1 : 0;

    const numRows = dataTable.getNumberOfRows();
    const numCols = dataTable.getNumberOfColumns();

    // Set up value-to-number converters.
    this.toNumber = [];
    for (let j = colStart; j < numCols; j++) {
      this.toNumber[j] = getByType(dataTable.getColumnType(j)).toNumber;
    }

    /**
     * The bucket lower boundary values.
     * When created, an extra value at the end is included.
     */
    const buckets: chartDefinitionTypes.CellType = this.generateBuckets();
    assert(Array.isArray(buckets));

    // Generate custom ticks for the buckets.
    const domainAxisTicks = clone(buckets);

    /** Just the numbers. */
    const bucketValues: number[] = map(buckets, (bucket) =>
      goog.isObject(bucket) ? bucket['v'] : bucket,
    );

    /** Return the number adjusted to the precision. */
    const roundNumByPrecision = (num: number): number =>
      Number(num.toPrecision(15)) - 0;

    const numBuckets = bucketValues.length;
    const bucketSize = roundNumByPrecision(bucketValues[1] - bucketValues[0]);
    const firstBucketStart = roundNumByPrecision(bucketValues[0]);
    const lastBucketStart = roundNumByPrecision(bucketValues[numBuckets - 1]);

    /**
     * @param value Input value.
     * @return Bucket index for the bucket in which the value belongs.
     *     This includes the bottom percentile bucket, if present.
     */
    const getBucketIndexByValue = (value: number): number => {
      if (bucketSize === 0 || value < firstBucketStart) {
        return 0;
      }
      if (value >= lastBucketStart) {
        return numBuckets - 1;
      }
      return Math.floor((value - firstBucketStart) / bucketSize);
    };

    // Build array of bucket items, the values/labels of each item in each
    // bucket.
    const bucketItems: chartDefinitionTypes.CellType[] = [];

    for (let j = colStart; j < numCols; j++) {
      // Initialize empty bucket items.
      bucketItems[j - colStart] = [];
      for (let i = 0; i < numBuckets; i++) {
        bucketItems[j - colStart].push([]);
      }
    }

    // Populate the histogram table.
    // The bucket items are not represented in this table, but plotted
    // with separate elements, if not too many.

    // The histogramBuckets property is used to generate explicit ticks.
    // Histogram bucket ticks need to be optional in case there are
    // too many to display. The explicit 'ticks' option will do what we need.
    const histogramTable = this.histogramTable;
    histogramTable.setColumnProperty(0, 'histogramBuckets', domainAxisTicks);

    // Add a row for each bucket, and set the first column to the bucket values.
    // All other columns must be initialized to 0.
    for (let i = 0; i < numBuckets; i++) {
      const row = [bucketValues[i]];
      for (let j = colStart; j < numCols; j++) {
        row.push(0);
      }
      histogramTable.addRow(row);
    }

    /** @desc Default label for a data item with no label given. */
    const MSG_DEFAULT_VALUE_LABEL = goog.getMsg('Value');

    // Iterate through the rows and columns of the incoming dataTable.
    for (let i = 0; i < numRows; i++) {
      const title = firstColIsLabel ? this.dataTable.getValue(i, 0) : '';
      for (let j = colStart; j < numCols; j++) {
        const val = this.dataTable.getValue(i, j);
        let num = val != null ? this.toNumber[j](val) : null;

        // Skip non-finite numbers, except if interpolateNulls then treat
        // null as 0.
        if (
          (typeof num === 'number' && !isFinite(num)) || // covers NaN and Infinity
          (num == null && !this.chartDef.interpolateNulls)
        ) {
          continue;
        }
        num = num || 0; // treat null as 0
        // Get the index of the bucket, the row index in histogramTable.
        const b = getBucketIndexByValue(num);

        // Compute the column index in histogramTable.
        // colStart is at 1 if the original table has a label column, and
        // 0 if it does not, in order to iterate only over data columns.
        // But the histogram table has a label column regardless whether
        // the original one does. Thus j + 1 - colStart, in order to map
        // colStart..length onto 1..length.
        const c = j + 1 - colStart;

        // Increment the number of items in this bucket.
        histogramTable.setValue(
          b,
          c,
          (Number(histogramTable.getValue(b, c)) || 0) + 1,
        );

        // Create info about the bucket item for later use in tooltips.
        // See {@link TooltipDefiner#createDatumTooltip_}.
        // Also map from bucketItem to dataTable index, for use when selecting.
        // See {@link EventHandler#handleDatumClick_}.
        const serieTitle =
          this.dataTable.getColumnLabel(j) || MSG_DEFAULT_VALUE_LABEL;
        const categoryTitle = title;
        const bucketItem = {
          row: i,
          column: j,
          label: {
            title,
            categoryTitle,
            serieTitle,
            content: this.dataTable.getFormattedValue(i, j),
            lines: [
              {
                title: serieTitle, // If nulls are included, display as zero.
                value: this.dataTable.getFormattedValue(i, j) || 0,
              },
            ],
          },
        };
        // Put this in buckets for now so they wind up sorted by bucket.
        const bucket = bucketItems[j - colStart][b];
        // Order of items in bucket will be same as incoming data.
        bucket.push(bucketItem);
      }
    }

    // Set up a mapping from dataTable index (column, row) to
    // element index for each bucket item, used for highlighting the selected
    // bucket item. See {@link AxisChartInteractivityDefiner#ringDatum_}.
    const elementIndexes: number[][] = [];
    for (let j = colStart; j < numCols; j++) {
      elementIndexes[j] = [];
    }

    const sortBucketItems = this.options.inferBooleanValue(
      'histogram.sortBucketItems',
    );

    // For each dataTable column, flatten the buckets for that column,
    // in bucketItems[j], to create elementIndexToBucketItems,
    // and store as histogram table column property.
    // Also iterate through elementIndexToBucketItems to build elementIndexes.
    for (let j = colStart; j < numCols; j++) {
      const elementIndexToBucketItems = flatten(bucketItems[j - colStart]);
      if (sortBucketItems) {
        elementIndexToBucketItems.sort((a, b) => {
          const valueA = a.label.lines[0].value;
          const valueB = b.label.lines[0].value;
          return valueA < valueB ? -1 : valueA > valueB ? 1 : 0;
        });
      }
      histogramTable.setColumnProperty(
        j - colStart,
        'histogramBucketItems',
        elementIndexToBucketItems,
      );
      forEach(elementIndexToBucketItems, (bucketItem, index) => {
        // Inverse mapping from histogramTable cell to index of bucketItem
        elementIndexes[bucketItem.column][bucketItem.row] = index;
      });
    }

    // Store the elementIndexes as histogram table column property.
    for (let j = colStart; j < numCols; j++) {
      histogramTable.setColumnProperty(
        j - colStart,
        'histogramElementIndexes',
        elementIndexes[j],
      );
    }
  }

  /** Generates buckets from the dataTable numbers. */
  generateBuckets(): number[] {
    const dataTable = this.dataTable;
    const numRows = dataTable.getNumberOfRows();
    const numCols = dataTable.getNumberOfColumns();

    const firstColIsLabel = dataTable.getColumnType(0) === 'string';
    const colStart = firstColIsLabel ? 1 : 0;

    let bucketValues =
      this.options.inferOptionalNumberArrayValue('histogram.buckets');
    if (bucketValues) {
      return bucketValues;
    }

    let nums: number[] = [];
    // Accumulate all numbers in the data.
    for (let i = 0; i < numRows; i++) {
      for (let j = colStart; j < numCols; j++) {
        const val = dataTable.getValue(i, j);
        let num = val != null ? this.toNumber[j](val) : null;
        // Skip non-finite numbers.
        // if interpolateNulls then treat null as 0.
        if (
          (typeof num === 'number' && !isFinite(num)) || // covers NaN and Infinity
          (num == null && !this.chartDef.interpolateNulls)
        ) {
          continue;
        }
        num = num || 0; // treat null as 0
        nums.push(num);
      }
    }
    // Sort so we can compute the percentile.
    nums = nums.sort((a, b) => a - b);

    /**
     * Given an array sorted in ascending order,
     * return the percentile according to:
     *     rank = percentile / 100 * array_length, rounding up.
     *
     * @param arr Input array.
     * @param percentile Input percentile.
     * @return rank Array index at this percentile rank.
     */
    const calcPercentileRank = (arr: number[], percentile: number): number => {
      return Math.ceil((percentile / 100) * arr.length);
    };
    const percentile = this.options.inferNumberValue(
      'histogram.lastBucketPercentile',
      0,
    );

    const pctMaxIndex = Math.min(
      nums.length - 1,
      calcPercentileRank(nums, 100 - percentile) - 1,
    );
    const pctMinIndex = Math.max(0, calcPercentileRank(nums, percentile) - 1);
    let min = nums[pctMinIndex];
    let max = nums[pctMaxIndex];

    // TODO(dlaliberte) The min and max values could be other than number.
    const userMinValue =
      this.options.inferOptionalNumberValue('histogram.minValue');
    const userMaxValue =
      this.options.inferOptionalNumberValue('histogram.maxValue');

    // Use minValue and maxValue but only if they exceed the min and max data.
    // This is analogous to the minValue and maxValue option for axes.
    // Let's change that!
    if (userMinValue != null) {
      min = Math.min(userMinValue, min);
    }
    if (userMaxValue != null) {
      max = Math.max(userMaxValue, max);
    }

    // Get the left and right screen coordinates of chartArea.
    const left = this.chartDef.chartArea.left;
    const right = left + this.chartDef.chartArea.width;

    const userMinSpacing = this.options.inferNumberValue(
      'histogram.minSpacing',
      1,
    );

    const userMinNumBuckets = this.options.inferNumberValue(
      'histogram.minNumBuckets',
      2,
    );
    const userMaxNumBuckets = this.options.inferNumberValue(
      'histogram.maxNumBuckets',
      (right - left) / userMinSpacing,
    );

    const numBucketsRuleName = this.options.inferOptionalStringValue(
      'histogram.numBucketsRule',
      // TODO(dlaliberte): Figure out how to pass the enum as type param.
      // tslint:disable-next-line:no-enum-object-escape
      NumBucketsRuleName,
    );
    const numBucketsRule = NUM_BUCKETS_RULE[numBucketsRuleName!];

    let numBuckets = numBucketsRule(numRows);
    // We could divide by the number of series. But we should not because
    // the bucketing for one series should not change just because another
    // series is added.

    // Constrain the number of buckets by the user min and max.
    numBuckets = Math.max(
      userMinNumBuckets,
      Math.min(userMaxNumBuckets, numBuckets),
    );

    // Now recompute the minSpacing from the numBuckets, since we only use
    // the minSpacing restriction in bucket generation.  But this is not going
    // to be enough, since minSpacing corresponds to maxNumBuckets, but there
    // is no maxSpacing which would correspond to minNumBuckets.  So instead,
    // if numBuckets is at the minimum, use the lesser of 2 times that number
    // and the average of the min and max.
    if (numBuckets === userMinNumBuckets) {
      numBuckets = Math.min(
        numBuckets * 2,
        (userMinNumBuckets + userMaxNumBuckets) / 2,
      );
    }
    let minSpacing = Math.max(
      userMinSpacing,
      (right - left) / (2 + numBuckets),
    );

    // Compute bucketSize from numBuckets
    let bucketSize = (max - min) / numBuckets;

    let userBucketSize = this.options.inferOptionalNumberValue(
      'histogram.bucketSize',
    );

    if (userBucketSize != null) {
      if (userBucketSize <= 0) {
        userBucketSize = null;
      } else {
        bucketSize = userBucketSize;
      }

      // Recompute numBuckets from this bucketSize, but constrained by the max.
      numBuckets = Math.min(userMaxNumBuckets, (max - min) / bucketSize);
      // And recompute minSpacing from the new numBuckets.
      minSpacing = Math.max(userMinSpacing, (right - left) / (2 * numBuckets));
    }

    // Extend min and max to include boundaries of first and last buckets.
    // But don't cross 0 (maybe should be baseline).
    min -= Math.min(bucketSize, Math.abs(min));
    max += Math.min(bucketSize, Math.abs(max));

    // Set up options to generate buckets from axis ticks.
    const bucketOptions = new Options([
      {'gridlines': {'minSpacing': minSpacing}},
    ]);

    // Create 'decorations' as if for axis ticks.
    const decorations = AxisDecorationsCreator.getSimpleNumberDecorations(
      min,
      max,
      left,
      right,
      bucketOptions,
    );

    bucketValues = map(decorations, (decoration) => decoration.getValue());
    return bucketValues;
  }

  /**
   * Returns whether the histogram should be drawn as a column chart.
   * True when either the histogram.hideBucketItems option is used,
   * or when the individual items are too small.
   *
   * Context:
   * For histograms, sub-pixel margins wind up looking stripey --
   * tiny bars of the same color nearly adjacent to each other get
   * helpfully antialiased and we wind up with weird halftone effects.
   * So for histograms only, if bars are less than 4 pixels tall, use no
   * margin, otherwise use 1px margin. See b/11111514.
   *
   * @param numericValueToPixelsFactor Height of the histogram items.
   * @param hideBucketItems Whether item dividers should be visible.
   * @return See above.
   */
  override treatHistogramAsColumnChart(
    numericValueToPixelsFactor: number,
    hideBucketItems: boolean,
  ): boolean {
    return numericValueToPixelsFactor < 4 || hideBucketItems;
  }

  /***
   * Counts the number of items that will be in the largest stack.
   *
   * @param isStacked Whether this is a stacked chart.
   * @return Number of items in largest bucket, or largest stack of
   *     buckets if stacked bucket chart.
   */
  override getLargestStack(isStacked: boolean): number {
    const dataView = this.dataView;
    const chartDef = this.chartDef;
    assert(dataView != null);

    const totals: number[][] = [];
    for (let i = 0; i < chartDef.categories.length; i++) {
      totals[i] = [];
      for (let j = 0; j < chartDef.series.length; j++) {
        const serie = chartDef.series[j];
        if (serie.type !== SerieType.BARS) {
          continue;
        }
        const target = isStacked ? 0 : j;
        totals[i][target] =
          (totals[i][target] || 0) +
          Number(dataView.getValue(i, serie.columns[ColumnRole.DATA][0]));
      }
    }
    let max = 0;
    for (let i = 0; i < totals.length; i++) {
      for (let j = 0; j < totals[i].length; j++) {
        max = Math.max(totals[i][j], max);
      }
    }
    return max;
  }
}

/** Names of rules for computing the number of buckets. */
enum NumBucketsRuleName {
  SQRT = 'sqrt',
  STURGES = 'sturges',
  RICE = 'rice',
}

/**
 * Map to functions for computing the number of buckets.
 * See https://en.wikipedia.org/wiki/Histogram#Number_of_bins_and_width
 */
const NUM_BUCKETS_RULE: {[key: string]: (p1: number) => number} = {
  'sqrt': (n: number) => {
    return Math.sqrt(n);
  },
  'rice': (n: number) => {
    return 2 * Math.cbrt(n);
  },
  'sturges': (n: number) => {
    return 1 + Math.log2(n);
  },
};
